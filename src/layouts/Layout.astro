---
// åªåŠ è½½æœ€å¸¸ç”¨çš„å­—ä½“æƒé‡ï¼Œå‡å°‘åŠ è½½æ—¶é—´
import "@fontsource/roboto/400.css";
import "@fontsource/roboto/700.css";

import ConfigCarrier from "@components/ConfigCarrier.astro";
import MusicPlayer from "@components/widget/MusicPlayer.svelte";
import Pio from "@components/widget/Pio.svelte"; // ä½¿ç”¨ Svelte ç‰ˆæœ¬çš„ Pio ç»„ä»¶
import { profileConfig, siteConfig } from "@/config";
import { widgetConfigs } from "../config";
import {
	AUTO_MODE,
	BANNER_HEIGHT,
	BANNER_HEIGHT_EXTEND,
	BANNER_HEIGHT_HOME,
	DARK_MODE,
	DEFAULT_THEME,
	LIGHT_MODE,
	PAGE_WIDTH,
} from "../constants/constants";
import { defaultFavicons } from "../constants/icon";
import type { Favicon, SakuraConfig } from "../types/config";
import { pathsEqual, url } from "../utils/url-utils";
import "katex/dist/katex.css";
import "../styles/mobile-navbar.css";
import "../styles/wallpaper-navbar-transparent.css";
import "../styles/main.css";

interface Props {
	title?: string;
	banner?: string;
	description?: string;
	lang?: string;
	setOGTypeArticle?: boolean;
	postSlug?: string;
}

let { title, banner, description, lang, setOGTypeArticle, postSlug } =
	Astro.props;

// apply a class to the body element to decide the height of the banner, only used for initial page load
// Swup can update the body for each page visit, but it's after the page transition, causing a delay for banner height change
// so use Swup hooks instead to change the height immediately when a link is clicked
const isHomePage = pathsEqual(Astro.url.pathname, url("/"));

// defines global css variables
// why doing this in Layout instead of GlobalStyles: https://github.com/withastro/astro/issues/6728#issuecomment-1502203757
const configHue = siteConfig.themeColor.hue;

// è·å–å¯¼èˆªæ é€æ˜æ¨¡å¼é…ç½®
const navbarTransparentMode =
	siteConfig.banner?.navbar?.transparentMode || "semi";
// åˆ¤æ–­æ˜¯å¦åº”è¯¥æ˜¾ç¤ºé¡¶éƒ¨é«˜å…‰æ•ˆæœï¼ˆåªåœ¨fullå’Œsemifullæ¨¡å¼ä¸‹æ˜¾ç¤ºï¼‰
const shouldShowTopHighlight =
	navbarTransparentMode === "full" || navbarTransparentMode === "semifull";

// è·å–é»˜è®¤bannerå›¾ç‰‡çš„è¾…åŠ©å‡½æ•°
const getDefaultBanner = (): string => {
	const src = siteConfig.banner.src;
	if (typeof src === "string") {
		return src;
	}
	if (Array.isArray(src)) {
		return src[0] || "";
	}
	if (src && typeof src === "object") {
		// ä¼˜å…ˆä½¿ç”¨desktopï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨mobile
		const desktopSrc = src.desktop;
		const mobileSrc = src.mobile;
		if (typeof desktopSrc === "string") {
			return desktopSrc;
		}
		if (Array.isArray(desktopSrc) && desktopSrc.length > 0) {
			return desktopSrc[0];
		}
		if (typeof mobileSrc === "string") {
			return mobileSrc;
		}
		if (Array.isArray(mobileSrc) && mobileSrc.length > 0) {
			return mobileSrc[0];
		}
	}
	return "";
};

if (!banner || typeof banner !== "string" || banner.trim() === "") {
	banner = getDefaultBanner();
}

// TODO don't use post cover as banner for now
banner = getDefaultBanner();

const enableBanner = siteConfig.banner.enable;

let pageTitle: string;
if (title) {
	pageTitle = `${title} - ${siteConfig.title}`;
} else {
	pageTitle = siteConfig.subtitle
		? `${siteConfig.title} - ${siteConfig.subtitle}`
		: siteConfig.title;
}

let ogImageUrl: string | undefined;
if (siteConfig.generateOgImages && postSlug) {
	ogImageUrl = new URL(`/og/${postSlug}.png`, Astro.site).toString();
} else {
	// ä¸ºé¦–é¡µæˆ–å…¶ä»–é¡µé¢è®¾ç½®é»˜è®¤åˆ†äº«å¡ç‰‡å›¾ç‰‡ï¼ˆä½¿ç”¨ç«™ç‚¹å›¾æ ‡æˆ–å¤´åƒï¼‰
	ogImageUrl = new URL(url("/favicon/icon.png"), Astro.site).toString();
}

const favicons: Favicon[] =
	siteConfig.favicon.length > 0 ? siteConfig.favicon : defaultFavicons;

// const siteLang = siteConfig.lang.replace('_', '-')
if (!lang) {
	lang = `${siteConfig.lang}`;
}
const siteLang = lang.replace("_", "-");

const bannerOffsetByPosition = {
	top: `${BANNER_HEIGHT_EXTEND}vh`,
	center: `${BANNER_HEIGHT_EXTEND / 2}vh`,
	bottom: "0",
};
const bannerOffset =
	bannerOffsetByPosition[siteConfig.banner.position || "center"];
---

<!DOCTYPE html>
<html lang={siteLang} class="bg-[var(--page-bg)] text-[14px] md:text-[16px]"
>
	<head>

		<title>{pageTitle}</title>

		<meta charset="UTF-8" />
		<meta name="description" content={description || pageTitle}>
		<meta name="author" content={profileConfig.name}>

		<meta property="og:site_name" content={siteConfig.title}>
		<meta property="og:url" content={Astro.url}>
		<meta property="og:title" content={pageTitle}>
		<meta property="og:description" content={description || pageTitle}>
		{ogImageUrl && <meta property="og:image" content={ogImageUrl} />}
		{ogImageUrl && <meta itemprop="image" content={ogImageUrl} />}
		{
			setOGTypeArticle ? (
				<meta property="og:type" content="article" />
			) : (
				<meta property="og:type" content="website" />
			)
		}

		<meta name="twitter:card" content="summary_large_image">
		<meta property="twitter:url" content={Astro.url}>
		<meta name="twitter:title" content={pageTitle}>
		<meta name="twitter:description" content={description || pageTitle}>
		{ogImageUrl && <meta name="twitter:image" content={ogImageUrl} />}

		<meta name="viewport" content="width=device-width" />
		<meta name="generator" content={Astro.generator} />
		{favicons.map(favicon => (
			<link rel="icon"
				  href={favicon.src.startsWith('/') ? url(favicon.src) : favicon.src}
				  sizes={favicon.sizes}
				  media={favicon.theme && `(prefers-color-scheme: ${favicon.theme})`}
			/>
		))}

		<!-- Set the theme before the page is rendered to avoid a flash -->
		<script is:inline define:vars={{DEFAULT_THEME, LIGHT_MODE, DARK_MODE, AUTO_MODE, BANNER_HEIGHT_EXTEND, PAGE_WIDTH, configHue}}>
			// Load the theme from local storage
			const theme = localStorage.getItem('theme') || DEFAULT_THEME;
			switch (theme) {
				case LIGHT_MODE:
					document.documentElement.classList.remove('dark');
					break
				case DARK_MODE:
					document.documentElement.classList.add('dark');
					break
				case AUTO_MODE:
					if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
						document.documentElement.classList.add('dark');
					} else {
						document.documentElement.classList.remove('dark');
					}
			}

			// Load the hue from local storage
			const hue = localStorage.getItem('hue') || configHue;
			document.documentElement.style.setProperty('--hue', hue);

			// calculate the --banner-height-extend, which needs to be a multiple of 4 to avoid blurry text
			let offset = Math.floor(window.innerHeight * (BANNER_HEIGHT_EXTEND / 100));
			offset = offset - offset % 4;
			document.documentElement.style.setProperty('--banner-height-extend', `${offset}px`);
		</script>
		<style define:vars={{
			configHue,
			'page-width': `${PAGE_WIDTH}rem`,
		}}></style>  <!-- defines global css variables. This will be applied to <html> <body> and some other elements idk why -->

		<style is:global>
			:root {
				--reading-progress-color: hsl(var(--hue, {configHue}), 80%, 60%);
			}

			.reading-progress-widget {
				position: fixed;
				right: 18px;
				bottom: 97px; /* å†ç•¥å¾®ä¸‹ç§» */
				z-index: 1200;
				min-width: 210px;
				padding: 10px 12px;
				display: flex;
				flex-direction: column;
				gap: 8px;
				justify-content: center;
				border-radius: 14px;
				background: color-mix(in srgb, var(--page-bg, #0b1221) 20%, rgba(255,255,255,0.7) 80%);
				backdrop-filter: blur(10px);
				box-shadow: 0 10px 30px rgba(0,0,0,0.18);
				border: 1px solid rgba(255,255,255,0.12);
				color: #111;
				opacity: 0;
				pointer-events: none;
				transform: translateY(8px) scale(0.82);
				transition:
					opacity 900ms ease,
					transform 900ms ease,
					border-radius 900ms ease,
					width 600ms ease,
					min-width 900ms ease,
					padding 900ms ease,
					gap 400ms ease;
			}

			.reading-progress-widget.visible {
				opacity: 0.95;
				pointer-events: auto;
				transform: translateY(0) scale(1);
			}

			.reading-progress-widget.faded {
				opacity: 0.6; /* æ›´é«˜é€æ˜åº¦ï¼Œæ›´åŠ æ·¡å‡º */
				pointer-events: none;
			}

			/* Idle: collapse to square at right */
			.reading-progress-widget.idle {
				width: 46px;
				min-width: 46px;
				padding: 10px;
				border-radius: 12px;
				transform: translateY(8px) scale(0.9);
				gap: 0;
				align-items: center;
			}

			.reading-progress-widget.idle .reading-progress-header {
				opacity: 0;
				max-height: 0;
				margin: 0;
				overflow: hidden;
			}

			.reading-progress-widget.idle .reading-progress-track {
				width: 100%;
				height: 6px;
			}

			.reading-progress-header {
				display: flex;
				align-items: center;
				justify-content: space-between;
				gap: 8px;
				font-size: 13px;
				font-weight: 500;
				color: #111;
				max-height: 32px;
				transition: opacity 260ms ease, max-height 260ms ease, margin 260ms ease;
			}

			.reading-progress-track {
				margin-top: 0;
				width: 100%;
				height: 8px;
				background: rgba(0,0,0,0.05);
				border-radius: 999px;
				overflow: hidden;
				position: relative;
				transition: height 260ms ease, width 260ms ease;
			}

			#reading-progress-bar {
				position: absolute;
				left: 0;
				top: 0;
				height: 100%;
				width: 0%;
				min-width: 2px;
				background: var(--reading-progress-color);
				transition: width 220ms cubic-bezier(.4,0,.2,1);
				border-radius: 999px;
				box-shadow: 0 0 4px 0 hsla(var(--hue, {configHue}), 80%, 60%, 0.35);
				opacity: 0;
			}

			@media (max-width: 640px) {
				.reading-progress-widget {
					min-width: 180px;
					padding: 8px 10px;
					right: 10px;
					bottom: 80px;
				}
				.reading-progress-header {
					font-size: 12px;
				}
				.reading-progress-track {
					height: 7px;
				}
			}
		</style>

		<slot name="head"></slot>

		<!-- Pio çœ‹æ¿å¨˜æ ·å¼ -->
		<link rel="stylesheet" href="/pio/static/pio.css" />

		<!-- Umami Analytics è„šæœ¬ - ç”¨äºé¡µé¢è®¿é—®è¿½è¸ª -->
		{profileConfig.umami?.enable && profileConfig.umami?.websiteId && (
			<script
				src="https://cloud.umami.is/script.js" // ä½ çš„Umamiå®ä¾‹åœ°å€
				defer
				data-website-id={profileConfig.umami.websiteId} // è¿™æ˜¯ä½ çš„ç½‘ç«™IDï¼Œç”¨äºè¿½è¸ª
			/>
		)}

		<link rel="alternate" type="application/rss+xml" title={profileConfig.name} href={`${Astro.site}rss.xml`}/>

		<!-- é˜²æ­¢åˆ·æ–°æ—¶åŸç”Ÿæ»šåŠ¨æ¡çŸ­æš‚é—ªç°ï¼šåœ¨ OverlayScrollbars åˆå§‹åŒ–å®Œæˆå‰å…ˆéšè—æ»šåŠ¨ -->
		<style>
			html:not(.os-init-done),
			body:not(.os-init-done) {
				overflow: hidden;
			}
			html.os-init-done,
			body.os-init-done {
				overflow: auto;
			}
		</style>



	</head>
	<body class=" min-h-screen " class:list={[{"lg:is-home": isHomePage, "enable-banner": enableBanner, "zen-maru-gothic-enabled": siteConfig.font.zenMaruGothic.enable}]}
		  data-overlayscrollbars-initialize
	>
		<!-- ä»…åœ¨æ–‡ç« é¡µé¢æ˜¾ç¤ºé˜…è¯»è¿›åº¦æ¡ -->
		<!-- æ€»æ˜¯æ¸²æŸ“è¿›åº¦æ¡ç»„ä»¶ï¼Œä½†åˆå§‹éšè— -->
<div class="reading-progress-widget" style="display:none;">
  <div class="reading-progress-header">
    <span>ğŸ“– é˜…è¯»è¿›åº¦</span>
    <span id="reading-progress-percent">0%</span>
  </div>
  <div class="reading-progress-track">
    <div id="reading-progress-bar"></div>
  </div>
</div>

		<!-- é¡µé¢é¡¶éƒ¨æ¸å˜é«˜å…‰æ•ˆæœ - åªåœ¨fullå’Œsemifullæ¨¡å¼ä¸‹æ˜¾ç¤º -->
		{shouldShowTopHighlight && <div class="top-gradient-highlight"></div>}
		<ConfigCarrier></ConfigCarrier>
		<slot />
		
		<!-- Music Player - ä½¿ç”¨ client:idle å»¶è¿ŸåŠ è½½ -->
		<MusicPlayer client:idle />
		
		<!-- Pio çœ‹æ¿å¨˜ç»„ä»¶ - ä½¿ç”¨ client:idle å»¶è¿ŸåŠ è½½ä»¥æå‡é¦–å±æ€§èƒ½ -->
		<!-- æ³¨æ„ï¼šPio ç»„ä»¶éœ€è¦æ”¾åœ¨ body æ ‡ç­¾å†…ï¼Œä½†è¦åœ¨å…¶ä»–å†…å®¹ä¹‹å‰ -->
		<!-- å¦‚æœå¯ç”¨äº†ä¾§è¾¹æ ï¼Œå¯èƒ½éœ€è¦è°ƒæ•´ z-index -->
		<Pio client:idle />
		
		<!-- increase the page height during page transition to prevent the scrolling animation from jumping -->
		<div id="page-height-extend" class="hidden h-[300vh]"></div>

		<!-- Sakura Effect -->
		{(widgetConfigs.sakura as SakuraConfig)?.enable && (
			<script define:vars={{ sakuraConfig: widgetConfigs.sakura }}>
				// æ¨±èŠ±å¯¹è±¡ç±»
				class Sakura {
					constructor(x, y, s, r, fn, idx, img, limitArray, config) {
						this.x = x;
						this.y = y;
						this.s = s;
						this.r = r;
						this.fn = fn;
						this.idx = idx;
						this.img = img;
						this.limitArray = limitArray;
						this.config = config;
					}

					draw(cxt) {
						cxt.save();
						cxt.translate(this.x, this.y);
						cxt.rotate(this.r);
						cxt.drawImage(this.img, 0, 0, 40 * this.s, 40 * this.s);
						cxt.restore();
					}

					update() {
						this.x = this.fn.x(this.x, this.y);
						this.y = this.fn.y(this.y, this.y);
						this.r = this.fn.r(this.r);

						// å¦‚æœæ¨±èŠ±è¶Šç•Œï¼Œé‡æ–°è°ƒæ•´ä½ç½®
						if (
							this.x > window.innerWidth ||
							this.x < 0 ||
							this.y > window.innerHeight ||
							this.y < 0
						) {
							// å¦‚æœæ¨±èŠ±ä¸åšé™åˆ¶
							if (this.limitArray[this.idx] === -1) {
								this.resetPosition();
							}
							// å¦åˆ™æ¨±èŠ±æœ‰é™åˆ¶
							else {
								if (this.limitArray[this.idx] > 0) {
									this.resetPosition();
									this.limitArray[this.idx]--;
								}
							}
						}
					}

					resetPosition() {
						this.r = getRandom('fnr', this.config);
						if (Math.random() > 0.4) {
							this.x = getRandom('x', this.config);
							this.y = 0;
							this.s = getRandom('s', this.config);
							this.r = getRandom('r', this.config);
						} else {
							this.x = window.innerWidth;
							this.y = getRandom('y', this.config);
							this.s = getRandom('s', this.config);
							this.r = getRandom('r', this.config);
						}
					}
				}

				// æ¨±èŠ±åˆ—è¡¨ç±»
				class SakuraList {
					constructor() {
						this.list = [];
					}

					push(sakura) {
						this.list.push(sakura);
					}

					update() {
						for (let i = 0, len = this.list.length; i < len; i++) {
							this.list[i].update();
						}
					}

					draw(cxt) {
						for (let i = 0, len = this.list.length; i < len; i++) {
							this.list[i].draw(cxt);
						}
					}

					get(i) {
						return this.list[i];
					}

					size() {
						return this.list.length;
					}
				}

				// è·å–éšæœºå€¼çš„å‡½æ•°
				function getRandom(option, config) {
					let ret;
					let random;

					switch (option) {
						case 'x':
							ret = Math.random() * window.innerWidth;
							break;
						case 'y':
							ret = Math.random() * window.innerHeight;
							break;
						case 's':
							ret = config.size.min + Math.random() * (config.size.max - config.size.min);
							break;
						case 'r':
							ret = Math.random() * 6;
							break;
						case 'fnx':
							random = config.speed.horizontal.min + Math.random() * (config.speed.horizontal.max - config.speed.horizontal.min);
							ret = function (x, y) {
								return x + random;
							};
							break;
						case 'fny':
							random = config.speed.vertical.min + Math.random() * (config.speed.vertical.max - config.speed.vertical.min);
							ret = function (x, y) {
								return y + random;
							};
							break;
						case 'fnr':
							ret = function (r) {
								return r + config.speed.rotation;
							};
							break;
					}
					return ret;
				}

				// æ¨±èŠ±ç®¡ç†å™¨ç±»
				class SakuraManager {
					constructor(config) {
						this.config = config;
						this.canvas = null;
						this.ctx = null;
						this.sakuraList = null;
						this.animationId = null;
						this.img = null;
						this.isRunning = false;
					}

					// åˆå§‹åŒ–æ¨±èŠ±ç‰¹æ•ˆ
					async init() {
						if (!this.config.enable || this.isRunning) {
							return;
						}

						// åˆ›å»ºå›¾ç‰‡å¯¹è±¡
						this.img = new Image();
						this.img.src = '/sakura.png'; // ä½¿ç”¨æ¨±èŠ±å›¾ç‰‡

						// ç­‰å¾…å›¾ç‰‡åŠ è½½å®Œæˆ
						await new Promise((resolve, reject) => {
							if (this.img) {
								this.img.onload = () => resolve();
								this.img.onerror = () => reject(new Error('Failed to load sakura image'));
							}
						});

						this.createCanvas();
						this.createSakuraList();
						this.startAnimation();
						this.isRunning = true;
					}

					// åˆ›å»ºç”»å¸ƒ
					createCanvas() {
						this.canvas = document.createElement('canvas');
						this.canvas.height = window.innerHeight;
						this.canvas.width = window.innerWidth;
						this.canvas.setAttribute('style', `position: fixed; left: 0; top: 0; pointer-events: none; z-index: ${this.config.zIndex};`);
						this.canvas.setAttribute('id', 'canvas_sakura');
						document.body.appendChild(this.canvas);
						this.ctx = this.canvas.getContext('2d');

						// ç›‘å¬çª—å£å¤§å°å˜åŒ–
						window.addEventListener('resize', this.handleResize.bind(this));
					}

					// åˆ›å»ºæ¨±èŠ±åˆ—è¡¨
					createSakuraList() {
						if (!this.img || !this.ctx) return;

						this.sakuraList = new SakuraList();
						const limitArray = new Array(this.config.sakuraNum).fill(this.config.limitTimes);

						for (let i = 0; i < this.config.sakuraNum; i++) {
							const randomX = getRandom('x', this.config);
							const randomY = getRandom('y', this.config);
							const randomR = getRandom('r', this.config);
							const randomS = getRandom('s', this.config);
							const randomFnx = getRandom('fnx', this.config);
							const randomFny = getRandom('fny', this.config);
							const randomFnR = getRandom('fnr', this.config);

							const sakura = new Sakura(
								randomX,
								randomY,
								randomS,
								randomR,
								{
									x: randomFnx,
									y: randomFny,
									r: randomFnR,
								},
								i,
								this.img,
								limitArray,
								this.config
							);

							sakura.draw(this.ctx);
							this.sakuraList.push(sakura);
						}
					}

					// å¼€å§‹åŠ¨ç”»
					startAnimation() {
						if (!this.ctx || !this.canvas || !this.sakuraList) return;

						const animate = () => {
							if (!this.ctx || !this.canvas || !this.sakuraList) return;

							this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
							this.sakuraList.update();
							this.sakuraList.draw(this.ctx);
							this.animationId = requestAnimationFrame(animate);
						};

						this.animationId = requestAnimationFrame(animate);
					}

					// å¤„ç†çª—å£å¤§å°å˜åŒ–
					handleResize() {
						if (this.canvas) {
							this.canvas.width = window.innerWidth;
							this.canvas.height = window.innerHeight;
						}
					}

					// åœæ­¢æ¨±èŠ±ç‰¹æ•ˆ
					stop() {
						if (this.animationId) {
							cancelAnimationFrame(this.animationId);
							this.animationId = null;
						}

						if (this.canvas) {
							document.body.removeChild(this.canvas);
							this.canvas = null;
						}

						window.removeEventListener('resize', this.handleResize.bind(this));
						this.isRunning = false;
					}

					// åˆ‡æ¢æ¨±èŠ±ç‰¹æ•ˆ
					toggle() {
						if (this.isRunning) {
							this.stop();
						} else {
							this.init();
						}
					}

					// æ›´æ–°é…ç½®
					updateConfig(newConfig) {
						const wasRunning = this.isRunning;
						if (wasRunning) {
							this.stop();
						}
						this.config = newConfig;
						if (wasRunning && newConfig.enable) {
							this.init();
						}
					}

					// è·å–è¿è¡ŒçŠ¶æ€
					getIsRunning() {
						return this.isRunning;
					}
				}

				// åˆ›å»ºå…¨å±€æ¨±èŠ±ç®¡ç†å™¨å®ä¾‹
				let globalSakuraManager = null;

				// åˆå§‹åŒ–æ¨±èŠ±ç‰¹æ•ˆ
				function initSakura(config) {
					if (globalSakuraManager) {
						globalSakuraManager.updateConfig(config);
					} else {
						globalSakuraManager = new SakuraManager(config);
						if (config.enable) {
							globalSakuraManager.init();
						}
					}
				}

				// æ¨±èŠ±ç‰¹æ•ˆåˆå§‹åŒ–
				(function() {
					// å…¨å±€æ ‡è®°ï¼Œç¡®ä¿æ¨±èŠ±ç‰¹æ•ˆåªåˆå§‹åŒ–ä¸€æ¬¡
					if (window.sakuraInitialized) {
						return;
					}
					
					// åˆå§‹åŒ–æ¨±èŠ±ç‰¹æ•ˆçš„å‡½æ•°
					const setupSakura = () => {
						if (sakuraConfig.enable && !window.sakuraInitialized) {
							initSakura(sakuraConfig);
							window.sakuraInitialized = true;
						}
					};
					
					// é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–æ¨±èŠ±ç‰¹æ•ˆ
					if (document.readyState === 'loading') {
						document.addEventListener('DOMContentLoaded', setupSakura);
					} else {
						setupSakura();
					}
				})();
			</script>
		)}
		
		<!-- Translate.js integration - lazy loading -->
		{siteConfig.translate?.enable && (
			<script>
				// æ‡’åŠ è½½translate.jsï¼Œåªæœ‰åœ¨éœ€è¦æ—¶æ‰åŠ è½½
				window.loadTranslateScript = function() {
					if (window.translate || document.getElementById('translate-script')) {
						return Promise.resolve();
					}
					
					return new Promise((resolve, reject) => {
						const script = document.createElement('script');
						script.src = '/translate.js';
						script.id = 'translate-script';
						script.async = true;
						script.onload = () => {
							if (typeof window.translate !== 'undefined') {
								resolve();
							} else {
								reject(new Error('translate.js loaded but window.translate not available'));
							}
						};
						script.onerror = reject;
						document.head.appendChild(script);
					});
				};
			</script>
		)}
	</body>
</html>

<style is:global define:vars={{
	bannerOffset,
	'banner-height-home': `${BANNER_HEIGHT_HOME}vh`,
	'banner-height': `${BANNER_HEIGHT}vh`,
}}>
@tailwind components;
@layer components {
	.enable-banner.is-home #banner-wrapper {
		@apply h-[var(--banner-height-home)] translate-y-[var(--banner-height-extend)]
	}
	.enable-banner #banner-wrapper {
		@apply h-[var(--banner-height-home)]
	}

	.enable-banner.is-home #banner {
		@apply h-[var(--banner-height-home)] translate-y-0
	}
	.enable-banner #banner {
		@apply h-[var(--banner-height-home)] translate-y-[var(--bannerOffset)]
	}
	.enable-banner.is-home #main-grid {
		@apply translate-y-[var(--banner-height-extend)];
	}
	.enable-banner #top-row {
		@apply h-[calc(var(--banner-height-home)_-_4.5rem)] transition-all duration-300
	}
	.enable-banner.is-home #sidebar-sticky {
		@apply top-[calc(1rem_-_var(--banner-height-extend))]
	}
	.navbar-hidden {
		@apply opacity-0 -translate-y-16
	}
	
	/* Water waves animation */
	.waves > .parallax use {
		animation: wave 25s cubic-bezier(0.5, 0.5, 0.45, 0.5) infinite;
	}

	@keyframes wave {
		0% {
			transform: translate3d(-90px, 0, 0);
		}
		100% {
			transform: translate3d(85px, 0, 0);
		}
	}
}
</style>

<script>
import { animationManager } from '../utils/animation-utils';
import 'overlayscrollbars/overlayscrollbars.css';
import {
	OverlayScrollbars,
	// ScrollbarsHidingPlugin,
	// SizeObserverPlugin,
	// ClickScrollPlugin
} from 'overlayscrollbars';
import {getHue, getStoredTheme, setHue, setTheme} from "../utils/setting-utils";
import {pathsEqual, url} from "../utils/url-utils";
import {
	BANNER_HEIGHT,
	BANNER_HEIGHT_HOME,
	BANNER_HEIGHT_EXTEND,
	MAIN_PANEL_OVERLAPS_BANNER_HEIGHT
} from "../constants/constants";
import { siteConfig } from '../config';

/* Preload fonts */
/* (async function() {
	try {
		await Promise.all([
			document.fonts.load("400 1em Roboto"),
			document.fonts.load("700 1em Roboto"),
		]);
		document.body.classList.remove("hidden");
	} catch (error) {
		console.log("Failed to load fonts:", error);
	}
})(); */

/* TODO This is a temporary solution for style flicker issue when the transition is activated */
/* issue link: https://github.com/withastro/astro/issues/8711, the solution get from here too */
/* update: fixed in Astro 3.2.4 */
/*
function disableAnimation() {
	const css = document.createElement('style')
	css.appendChild(
		document.createTextNode(
			`*{
              -webkit-transition:none!important;
              -moz-transition:none!important;
              -o-transition:none!important;
              -ms-transition:none!important;
              transition:none!important
              }`
		)
	)
	document.head.appendChild(css)

	return () => {
		// Force restyle
		;(() => window.getComputedStyle(document.body))()

		// Wait for next tick before removing
		setTimeout(() => {
			document.head.removeChild(css)
		}, 1)
	}
}
*/

const bannerEnabled = !!document.getElementById('banner-wrapper')

function setClickOutsideToClose(panel: string, ignores: string[]) {
	document.addEventListener("click", event => {
		let panelDom = document.getElementById(panel);
		let tDom = event.target;
		if (!(tDom instanceof Node)) return;		// Ensure the event target is an HTML Node
		for (let ig of ignores) {
			let ie = document.getElementById(ig)
			if (ie == tDom || (ie?.contains(tDom))) {
				return;
			}
		}
		panelDom!.classList.add("float-panel-closed");
	});
}
setClickOutsideToClose("display-setting", ["display-setting", "display-settings-switch"])
setClickOutsideToClose("nav-menu-panel", ["nav-menu-panel", "nav-menu-switch"])
setClickOutsideToClose("search-panel", ["search-panel", "search-bar", "search-switch"])


function loadTheme() {
	const theme = getStoredTheme()
	setTheme(theme)
}

function loadHue() {
	setHue(getHue())
}

function initCustomScrollbar() {
	const bodyElement = document.querySelector('body');
	if (!bodyElement) return;
	OverlayScrollbars(
		{
			target: bodyElement,
			cancel: {
				nativeScrollbarsOverlaid: true,
			}
		}, {
		scrollbars: {
			theme: 'os-theme-dark',
			autoHide: 'move',
			autoHideDelay: 500,
			autoHideSuspend: false,
		},
	});

	// é˜²æ­¢åˆ·æ–°æ—¶åŸç”Ÿæ»šåŠ¨æ¡çŸ­æš‚é—ªç°ï¼šç­‰ OverlayScrollbars æ¥ç®¡åå†æ¢å¤æ»šåŠ¨
	document.documentElement.classList.add('os-init-done');
	document.body.classList.add('os-init-done');

	// åªå¤„ç†katexå…ƒç´ çš„æ»šåŠ¨æ¡
	const katexElements = document.querySelectorAll('.katex-display:not([data-scrollbar-initialized])') as NodeListOf<HTMLElement>;
	katexElements.forEach(element => {
		if (!element.parentNode) return;

		const container = document.createElement('div');
		container.className = 'katex-display-container';
		element.parentNode.insertBefore(container, element);
		container.appendChild(element);

		// ä½¿ç”¨ç®€å•çš„CSSæ»šåŠ¨æ¡è€Œä¸æ˜¯OverlayScrollbars
		container.style.cssText = `
			overflow-x: auto;
			scrollbar-width: thin;
			scrollbar-color: rgba(0,0,0,0.3) transparent;
		`;
		
		// ä¸ºwebkitæµè§ˆå™¨æ·»åŠ è‡ªå®šä¹‰æ»šåŠ¨æ¡æ ·å¼
		const style = document.createElement('style');
		style.textContent = `
			.katex-display-container::-webkit-scrollbar {
				height: 6px;
			}
			.katex-display-container::-webkit-scrollbar-track {
				background: transparent;
			}
			.katex-display-container::-webkit-scrollbar-thumb {
				background: rgba(0,0,0,0.3);
				border-radius: 3px;
			}
			.katex-display-container::-webkit-scrollbar-thumb:hover {
				background: rgba(0,0,0,0.5);
			}
		`;
		if (!document.head.querySelector('style[data-katex-scrollbar]')) {
			style.setAttribute('data-katex-scrollbar', 'true');
			document.head.appendChild(style);
		}

		element.setAttribute('data-scrollbar-initialized', 'true');
	});
}

function showBanner() {
	if (!siteConfig.banner.enable) return;

	// ä½¿ç”¨requestAnimationFrameä¼˜åŒ–DOMæ“ä½œ
	requestAnimationFrame(() => {
		// Handle single image banner (desktop)
		const banner = document.getElementById('banner');
		if (banner) {
			banner.classList.remove('opacity-0', 'scale-105');
		}

		// Handle mobile single image banner - ä½¿ç”¨ä¸ç”µè„‘ç«¯ç›¸åŒçš„é€»è¾‘
		const mobileBanner = document.querySelector('.block.lg\\:hidden[alt="Mobile banner image of the blog"]');
		if (mobileBanner && !document.getElementById('banner-carousel')) {
			// ç§»åŠ¨ç«¯ä½¿ç”¨ä¸ç”µè„‘ç«¯ç›¸åŒçš„åˆå§‹åŒ–é€»è¾‘
			mobileBanner.classList.remove('opacity-0', 'scale-105');
			mobileBanner.classList.add('opacity-100');
		}

		// Handle carousel banner - ç«‹å³åˆå§‹åŒ–ï¼Œç§»é™¤å»¶è¿Ÿ
		const carousel = document.getElementById('banner-carousel');
		if (carousel) {
			// ç«‹å³åˆå§‹åŒ–è½®æ’­ï¼Œç§»é™¤å»¶è¿Ÿä»¥æ”¹å–„æµç•…æ€§
			initCarousel();
		}
	});
}

function initCarousel() {
	const carouselItems = document.querySelectorAll('.carousel-item');
	
	// æ ¹æ®å±å¹•å°ºå¯¸è¿‡æ»¤æœ‰æ•ˆçš„è½®æ’­é¡¹
	const isMobile = window.innerWidth < 1024; // lg breakpoint
	const validItems = Array.from(carouselItems).filter(item => {
		if (isMobile) {
			// ç§»åŠ¨ç«¯ï¼šåªæ˜¾ç¤ºæœ‰mobileå›¾ç‰‡çš„é¡¹ç›®
			return item.querySelector('.block.lg\\:hidden');
		} else {
			// æ¡Œé¢ç«¯ï¼šåªæ˜¾ç¤ºæœ‰desktopå›¾ç‰‡çš„é¡¹ç›®
			return item.querySelector('.hidden.lg\\:block');
		}
	});
	
	// Check if carousel is disabled but we have multiple images - show random image
	if (validItems.length > 1 && !siteConfig.banner.carousel?.enable) {
		// Hide all images first
		carouselItems.forEach((item, index) => {
			item.classList.add('opacity-0', 'scale-110');
			item.classList.remove('opacity-100', 'scale-100');
		});
		
		// Show random valid image
		const randomIndex = Math.floor(Math.random() * validItems.length);
		const randomItem = validItems[randomIndex];
		
		randomItem.classList.add('opacity-100', 'scale-100');
		randomItem.classList.remove('opacity-0', 'scale-110');
		return;
	}
	
	if (validItems.length > 1 && siteConfig.banner.carousel?.enable) {
		let currentIndex = 0;
		const interval = siteConfig.banner.carousel?.interval || 6;
		let carouselInterval;
		let isPaused = false;

		// ç§»åŠ¨ç«¯è§¦æ‘¸æ‰‹åŠ¿æ”¯æŒ
		let startX = 0;
		let startY = 0;
		let isSwiping = false;
		const carousel = document.getElementById('banner-carousel');

		// åˆ‡æ¢å›¾ç‰‡çš„å‡½æ•° - åŸºäºæœ‰æ•ˆé¡¹ç›®
		function switchToSlide(index) {
			// éšè—å½“å‰å›¾ç‰‡
			const currentItem = validItems[currentIndex];
			currentItem.classList.remove('opacity-100', 'scale-100');
			currentItem.classList.add('opacity-0', 'scale-110');

			// æ›´æ–°ç´¢å¼•
			currentIndex = index;
			
			// æ˜¾ç¤ºæ–°å›¾ç‰‡
			const nextItem = validItems[currentIndex];
			nextItem.classList.add('opacity-100', 'scale-100');
			nextItem.classList.remove('opacity-0', 'scale-110');
		}

		// åˆå§‹åŒ–ï¼šéšè—æ‰€æœ‰å›¾ç‰‡ï¼Œåªæ˜¾ç¤ºç¬¬ä¸€å¼ æœ‰æ•ˆå›¾ç‰‡
		carouselItems.forEach((item) => {
			item.classList.add('opacity-0', 'scale-110');
			item.classList.remove('opacity-100', 'scale-100');
		});
		
		// æ˜¾ç¤ºç¬¬ä¸€å¼ æœ‰æ•ˆå›¾ç‰‡
		if (validItems.length > 0) {
			validItems[0].classList.add('opacity-100', 'scale-100');
			validItems[0].classList.remove('opacity-0', 'scale-110');
		}

		// ç§»åŠ¨ç«¯è§¦æ‘¸äº‹ä»¶
		if (carousel && 'ontouchstart' in window) {
			carousel.addEventListener('touchstart', (e) => {
				startX = e.touches[0].clientX;
				startY = e.touches[0].clientY;
				isSwiping = false;
				isPaused = true;
				clearInterval(carouselInterval);
			}, { passive: true });

			carousel.addEventListener('touchmove', (e) => {
				if (!startX || !startY) return;
				
				const diffX = Math.abs(e.touches[0].clientX - startX);
				const diffY = Math.abs(e.touches[0].clientY - startY);
				
				// åˆ¤æ–­æ˜¯å¦ä¸ºæ°´å¹³æ»‘åŠ¨
				if (diffX > diffY && diffX > 30) {
					isSwiping = true;
					e.preventDefault();
				}
			}, { passive: false });

			carousel.addEventListener('touchend', (e) => {
				if (!startX || !startY || !isSwiping) {
					isPaused = false;
					startCarousel();
					return;
				}
				
				const endX = e.changedTouches[0].clientX;
				const diffX = startX - endX;
				
				// æ»‘åŠ¨è·ç¦»è¶…è¿‡50pxæ‰åˆ‡æ¢
				if (Math.abs(diffX) > 50) {
					if (diffX > 0) {
					// å‘å·¦æ»‘åŠ¨ï¼Œæ˜¾ç¤ºä¸‹ä¸€å¼ 
					const nextIndex = (currentIndex + 1) % validItems.length;
					switchToSlide(nextIndex);
				} else {
					// å‘å³æ»‘åŠ¨ï¼Œæ˜¾ç¤ºä¸Šä¸€å¼ 
					const prevIndex = (currentIndex - 1 + validItems.length) % validItems.length;
					switchToSlide(prevIndex);
				}
				}
				
				startX = 0;
				startY = 0;
				isSwiping = false;
				isPaused = false;
				
				// é‡æ–°å¼€å§‹è‡ªåŠ¨è½®æ’­
				startCarousel();
			}, { passive: true });
		}

		// å¼€å§‹è½®æ’­çš„å‡½æ•°
		function startCarousel() {
			clearInterval(carouselInterval);
			carouselInterval = setInterval(() => {
				if (!isPaused) {
					const nextIndex = (currentIndex + 1) % validItems.length;
					switchToSlide(nextIndex);
				}
			}, interval * 1000);
		}

		// é¼ æ ‡æ‚¬åœæš‚åœï¼ˆæ¡Œé¢ç«¯ï¼‰
		if (carousel) {
			carousel.addEventListener('mouseenter', () => {
				isPaused = true;
				clearInterval(carouselInterval);
			});

			carousel.addEventListener('mouseleave', () => {
				isPaused = false;
				startCarousel();
			});
		}

		// å¼€å§‹è‡ªåŠ¨è½®æ’­
		startCarousel();
	}
}

function initTranslate() {
	if (!siteConfig.translate?.enable || typeof window.translate === 'undefined') return;
	
	// é…ç½®translate.js
	if (siteConfig.translate.service && window.translate) {
		window.translate.service.use(siteConfig.translate.service);
	}
	
	if (siteConfig.translate.defaultLanguage && window.translate) {
		window.translate.language.setLocal(siteConfig.translate.defaultLanguage);
	}
	
	if (siteConfig.translate.autoDiscriminate && window.translate) {
		window.translate.setAutoDiscriminateLocalLanguage();
	}
	
	// è®¾ç½®å¿½ç•¥çš„ç±»åå’Œæ ‡ç­¾
	if (siteConfig.translate.ignoreClasses && window.translate) {
		siteConfig.translate.ignoreClasses.forEach(className => {
			window.translate.ignore.class.push(className);
		});
	}
	
	if (siteConfig.translate.ignoreTags && window.translate) {
		siteConfig.translate.ignoreTags.forEach(tagName => {
			window.translate.ignore.tag.push(tagName);
		});
	}
	
	// ä¸æ˜¾ç¤ºé»˜è®¤çš„selecté€‰æ‹©æ¡†
	if (siteConfig.translate.showSelectTag === false && window.translate) {
		window.translate.selectLanguageTag.show = false;
	}
	
	// ç¦ç”¨è‡ªåŠ¨ä¿å­˜ç¿»è¯‘çŠ¶æ€åˆ°localStorage
	if (window.translate) {
		window.translate.storage.set = function() {
			// ç©ºå‡½æ•°ï¼Œé˜»æ­¢ä¿å­˜çŠ¶æ€
		};
	
		// å¯åŠ¨ç¿»è¯‘ç›‘å¬
		window.translate.listener.start();
	
		// æ‰§è¡Œç¿»è¯‘åˆå§‹åŒ–
		window.translate.execute();
	}
}

// æ‡’åŠ è½½å¹¶åˆå§‹åŒ–ç¿»è¯‘åŠŸèƒ½
async function loadAndInitTranslate() {
	if (!siteConfig.translate?.enable) return;
	
	try {
		await window.loadTranslateScript();
		initTranslate();
	} catch (error) {
		console.error('Failed to load translate.js:', error);
	}
}



// ç»Ÿä¸€çš„é¡µé¢åŠ è½½äº‹ä»¶æ´¾å‘å™¨ï¼Œç¡®ä¿åˆæ¬¡å’Œæ¯æ¬¡ Swup åˆ‡æ¢åéƒ½èƒ½é€šçŸ¥åˆ°é¡µé¢è„šæœ¬
const emitPageLoaded = () => {
	const event = new CustomEvent('mizuki:page:loaded', {
		detail: { path: window.location.pathname, timestamp: Date.now() }
	});
	window.dispatchEvent(event);
	// åŒæ—¶å‘åˆ° documentï¼Œå…¼å®¹ä¹‹å‰çš„ç›‘å¬å†™æ³•
	document.dispatchEvent(event);
};

function refreshContentManagerAuthStatus() {
	if (!window.location.pathname.includes('/content-manager')) return;
	const githubToken = localStorage.getItem('github_access_token');
	const statusText = document.getElementById('auth-status-text');
	const statusIndicator = document.getElementById('auth-status-indicator');
	const authBtnText = document.getElementById('auth-btn-text');
	if (statusText && statusIndicator && authBtnText) {
		if (githubToken) {
			statusText.textContent = 'å·²è®¤è¯';
			statusIndicator.className = 'w-3 h-3 rounded-full bg-green-500 mr-2';
			authBtnText.textContent = 'é€€å‡º';
		} else {
			statusText.textContent = 'æœªè®¤è¯';
			statusIndicator.className = 'w-3 h-3 rounded-full bg-red-500 mr-2';
			authBtnText.textContent = 'ç™»å½•';
		}
	}
}

function refreshCreateContentAuthStatus() {
	if (!window.location.pathname.includes('/create-content')) return;
	const githubToken = localStorage.getItem('github_access_token');
	const statusText = document.getElementById('create-auth-status-text');
	const statusIndicator = document.getElementById('create-auth-status-indicator');
	const authBtnText = document.getElementById('create-auth-btn-text');
	if (statusText && statusIndicator && authBtnText) {
		if (githubToken) {
			statusText.textContent = 'å·²è®¤è¯';
			statusIndicator.className = 'w-3 h-3 rounded-full bg-green-500 mr-2';
			authBtnText.textContent = 'é€€å‡º';
		} else {
			statusText.textContent = 'æœªè®¤è¯';
			statusIndicator.className = 'w-3 h-3 rounded-full bg-red-500 mr-2';
			authBtnText.textContent = 'ç™»å½•';
		}
	}
}

const handleGlobalPageLoaded = () => {
	refreshContentManagerAuthStatus();
	refreshCreateContentAuthStatus();
};

const setup = () => {
	// TODO: temp solution to change the height of the banner
/*
	window.swup.hooks.on('animation:out:start', () => {
		const path = window.location.pathname
		const body = document.querySelector('body')
		if (path[path.length - 1] === '/' && !body.classList.contains('is-home')) {
			body.classList.add('is-home')
		} else if (path[path.length - 1] !== '/' && body.classList.contains('is-home')) {
			body.classList.remove('is-home')
		}
	})
*/
	window.swup.hooks.on('link:click', () => {
		// Remove the delay for the first time page load
		document.documentElement.style.setProperty('--content-delay', '0ms')

		// ç®€åŒ–navbarå¤„ç†é€»è¾‘
		if (bannerEnabled) {
			const navbar = document.getElementById('navbar-wrapper')
			if (navbar && document.body.classList.contains('lg:is-home')) {
				const threshold = window.innerHeight * (BANNER_HEIGHT / 100) - 88
				if (document.documentElement.scrollTop >= threshold) {
					navbar.classList.add('navbar-hidden')
				}
			}
		}
	})
	window.swup.hooks.on('content:replace', () => {
            // åªå¤„ç†æ–°çš„katexå…ƒç´ çš„æ»šåŠ¨æ¡ï¼Œä½¿ç”¨åŸç”ŸCSSæ»šåŠ¨æ¡
            initCustomScrollbar();
            
            // æ£€æŸ¥å½“å‰é¡µé¢æ˜¯å¦ä¸ºæ–‡ç« é¡µé¢ï¼ˆæœ‰TOCå…ƒç´ ï¼‰
            const tocWrapper = document.getElementById('toc-wrapper');
            const isArticlePage = tocWrapper !== null;
            
            // åªåœ¨æ–‡ç« é¡µé¢é‡æ–°åˆå§‹åŒ– TOC ç»„ä»¶
            if (isArticlePage) {
                const tocElement = document.querySelector('table-of-contents');
                if (tocElement && typeof (tocElement as any).init === 'function') {
                    // ä½¿ç”¨ requestAnimationFrame æ›¿ä»£ setTimeout ä»¥è·å¾—æ›´å¿«çš„å“åº”
                    requestAnimationFrame(() => {
                        (tocElement as any).init();
                    });
                }
            }

            // æ–°å¢ï¼šé€šçŸ¥é¡µé¢è„šæœ¬åœ¨ Swup åˆ‡æ¢åé‡æ–°åˆå§‹åŒ–
			emitPageLoaded();
        })
	window.swup.hooks.on('visit:start', (visit: {to: {url: string}}) => {
		// change banner height immediately when a link is clicked
		const bodyElement = document.querySelector('body')
		const isHomePage = pathsEqual(visit.to.url, url('/'))
		
		if (isHomePage) {
			bodyElement!.classList.add('lg:is-home');
		} else {
			bodyElement!.classList.remove('lg:is-home');
		}

		// Control banner text visibility based on page
		const bannerTextOverlay = document.querySelector('.banner-text-overlay')
		if (bannerTextOverlay) {
			if (isHomePage) {
				bannerTextOverlay.classList.remove('hidden')
			} else {
				bannerTextOverlay.classList.add('hidden')
			}
		}

		// Control navbar transparency based on page
		const navbar = document.getElementById('navbar')
		if (navbar) {
			navbar.setAttribute('data-is-home', isHomePage.toString())
			
			// é‡æ–°åˆå§‹åŒ–semifullæ¨¡å¼çš„æ»šåŠ¨æ£€æµ‹
			const transparentMode = navbar.getAttribute('data-transparent-mode')
			if (transparentMode === 'semifull') {
				// é‡æ–°è°ƒç”¨åˆå§‹åŒ–å‡½æ•°æ¥é‡æ–°ç»‘å®šæ»šåŠ¨äº‹ä»¶
				if (typeof window.initSemifullScrollDetection === 'function') {
					window.initSemifullScrollDetection()
				}
			}
		}

		// Control mobile banner visibility based on page with improved staging animation
		const bannerWrapper = document.getElementById('banner-wrapper')
		const mainContentWrapper = document.querySelector('.absolute.w-full.z-30')
		
		if (bannerWrapper && mainContentWrapper) {
			if (isHomePage) {
				// é¦–é¡µï¼šä½¿ç”¨ requestAnimationFrame ä¼˜åŒ–åŠ¨ç”»æ—¶åº
				requestAnimationFrame(() => {
					bannerWrapper.classList.remove('mobile-hide-banner')
					requestAnimationFrame(() => {
						mainContentWrapper.classList.remove('mobile-main-no-banner')
					})
				})
			} else {
				// éé¦–é¡µï¼šåŒæ­¥éšè—ä»¥æé«˜å“åº”é€Ÿåº¦
				bannerWrapper.classList.add('mobile-hide-banner')
				mainContentWrapper.classList.add('mobile-main-no-banner')
			}
		}

		// increase the page height during page transition to prevent the scrolling animation from jumping
		const heightExtend = document.getElementById('page-height-extend')
		if (heightExtend) {
			heightExtend.classList.remove('hidden')
		}

		// Hide the TOC while scrolling back to top
		let toc = document.getElementById('toc-wrapper');
		if (toc) {
			toc.classList.add('toc-not-ready')
		}
	});
	window.swup.hooks.on('page:view', () => {
		// hide the temp high element when the transition is done
		const heightExtend = document.getElementById('page-height-extend')
		if (heightExtend) {
			heightExtend.classList.remove('hidden')
		}
		
		// ç¡®ä¿é¡µé¢æ»šåŠ¨åˆ°é¡¶éƒ¨ï¼Œç‰¹åˆ«æ˜¯ç§»åŠ¨ç«¯bannerå…³é—­æ—¶
		window.scrollTo({
			top: 0,
			behavior: 'instant'
		});
		
		// æ£€æŸ¥å½“å‰é¡µé¢æ˜¯å¦ä¸ºæ–‡ç« é¡µé¢ï¼Œå¦‚æœæ˜¯åˆ™è§¦å‘è‡ªå®šä¹‰äº‹ä»¶ç”¨äºåˆå§‹åŒ–è¯„è®ºç³»ç»Ÿ
		// ä½¿ç”¨ requestAnimationFrame æ›¿ä»£ setTimeout ä»¥è·å¾—æ›´å¿«çš„å“åº”
		requestAnimationFrame(() => {
			emitPageLoaded();
		});
	});
	window.swup.hooks.on('visit:end', (_visit: {to: {url: string}}) => {
		// ä½¿ç”¨ requestAnimationFrame ä»£æ›¿ setTimeout ä»¥è·å¾—æ›´å¥½çš„æ€§èƒ½
		requestAnimationFrame(() => {
			const heightExtend = document.getElementById('page-height-extend')
			if (heightExtend) {
				heightExtend.classList.add('hidden')
			}

            // Just make the transition looks better
            const toc = document.getElementById('toc-wrapper');
            if (toc) {
                toc.classList.remove('toc-not-ready')
            }
        })
	});
}

// é¦–æ¬¡é¡µé¢åŠ è½½ä¹Ÿæ´¾å‘ä¸€æ¬¡ï¼Œç¡®ä¿é Swup è¿›å…¥æ—¶é¡µé¢è„šæœ¬èƒ½åˆå§‹åŒ–
if (document.readyState === 'loading') {
	document.addEventListener('DOMContentLoaded', () => {
		emitPageLoaded();
		handleGlobalPageLoaded();
	}, { once: true });
} else {
	emitPageLoaded();
	handleGlobalPageLoaded();
}

window.addEventListener('mizuki:page:loaded', handleGlobalPageLoaded);

if (window?.swup?.hooks) {
	setup()
} else {
	document.addEventListener('swup:enable', setup)
}

let backToTopBtn = document.getElementById('back-to-top-btn');
let toc = document.getElementById('toc-wrapper');
let navbar = document.getElementById('navbar-wrapper')


// èŠ‚æµå‡½æ•°
function throttle(func: Function, limit: number) {
	let inThrottle: boolean;
	return function(this: any) {
		const args = arguments;
		const context = this;
		if (!inThrottle) {
			func.apply(context, args);
			inThrottle = true;
			setTimeout(() => inThrottle = false, limit);
		}
	}
}

function scrollFunction() {
	const scrollTop = document.documentElement.scrollTop;
	const bannerHeight = window.innerHeight * (BANNER_HEIGHT / 100);

	// æ‰¹é‡å¤„ç†DOMæ“ä½œ
	requestAnimationFrame(() => {
		if (backToTopBtn) {
			if (scrollTop > bannerHeight) {
				backToTopBtn.classList.remove('hide')
			} else {
				backToTopBtn.classList.add('hide')
			}
		}

		if (bannerEnabled && toc) {
			if (scrollTop > bannerHeight) {
				toc.classList.remove('toc-hide')
			} else {
				toc.classList.add('toc-hide')
			}
		}

		if (bannerEnabled && navbar) {
			const isHome = document.body.classList.contains('lg:is-home') && window.innerWidth >= 1024;
			const currentBannerHeight = isHome ? BANNER_HEIGHT_HOME : BANNER_HEIGHT;
			const threshold = window.innerHeight * (currentBannerHeight / 100) - 88;
			
			if (scrollTop >= threshold) {
				navbar.classList.add('navbar-hidden')
			} else {
				navbar.classList.remove('navbar-hidden')
			}
		}
	});
}

// ä½¿ç”¨èŠ‚æµä¼˜åŒ–æ»šåŠ¨æ€§èƒ½
window.onscroll = throttle(scrollFunction, 16); // çº¦60fps

window.onresize = () => {
	// calculate the --banner-height-extend, which needs to be a multiple of 4 to avoid blurry text
	let offset = Math.floor(window.innerHeight * (BANNER_HEIGHT_EXTEND / 100));
	offset = offset - offset % 4;
	document.documentElement.style.setProperty('--banner-height-extend', `${offset}px`);
}

// é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–bannerå’Œè½®æ’­å›¾
if (document.readyState === 'loading') {
	document.addEventListener('DOMContentLoaded', () => {
		showBanner();
		initCustomScrollbar();
	});
} else {
	showBanner();
	initCustomScrollbar();
}

</script>

<script>
import PhotoSwipeLightbox from "photoswipe/lightbox"
import "photoswipe/style.css"

let lightbox: PhotoSwipeLightbox

function createPhotoSwipe() {
	lightbox = new PhotoSwipeLightbox({
		gallery: ".custom-md img, #post-cover img, .moment-images img",
		pswpModule: () => import("photoswipe"),
		closeSVG: '<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#ffffff"><path d="M480-424 284-228q-11 11-28 11t-28-11q-11-11-11-28t11-28l196-196-196-196q-11-11-11-28t11-28q11-11 28-11t28 11l196 196 196-196q11-11 11-28t28 11q11 11 11 28t-11 28L536-480l196 196q11 11 11 28t-11 28q-11 11-28 11t-28-11L480-424Z"/></svg>',
		zoomSVG: '<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#ffffff"><path d="M340-540h-40q-17 0-28.5-11.5T260-580q0-17 11.5-28.5T300-620h40v-40q0-17 11.5-28.5T380-700q17 0 28.5 11.5T420-660v40h40q17 0 28.5 11.5T500-580q0 17-11.5 28.5T460-540h-40v40q0 17-11.5 28.5T380-460q-17 0-28.5-11.5T340-500v-40Zm0-80q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg>',
		padding: { top: 20, bottom: 20, left: 20, right: 20 },
		wheelToZoom: true,
		arrowPrev: false,
		arrowNext: false,
		imageClickAction: 'close',
		tapAction: 'close',
		doubleTapAction: 'zoom',
	})

	// Add filter BEFORE lightbox is initialized
	lightbox.addFilter("domItemData", (itemData, element) => {
		if (element instanceof HTMLImageElement) {
			itemData.src = element.src

			itemData.w = Number(element.naturalWidth || window.innerWidth)
			itemData.h = Number(element.naturalHeight || window.innerHeight)

			itemData.msrc = element.src
		}

		return itemData
	})

	// Initialize lightbox AFTER adding filters
	lightbox.init()
}

const setup = () => {
	if (!lightbox) {
		createPhotoSwipe()
	}
	window.swup.hooks.on("page:view", () => {
		createPhotoSwipe()
	})

	window.swup.hooks.on(
		"content:replace",
		() => {
			lightbox?.destroy?.()
		},
		{ before: true },
	)
}

if (window.swup) {
	setup()
} else {
	document.addEventListener("swup:enable", setup)
}
</script>

<script is:inline>
  // è¿›åº¦æ¡åªåœ¨/posts/é¡µé¢æ˜¾ç¤ºï¼ŒSwupåˆ‡æ¢åè‡ªåŠ¨åˆ¤æ–­
  function handleReadingProgressDisplay() {
    const widget = document.querySelector('.reading-progress-widget');
    if (!widget) return;
    if (location.pathname.startsWith('/posts/')) {
      widget.style.display = '';
    } else {
      widget.style.display = 'none';
    }
  }

  // è¿›åº¦æ¡é€»è¾‘
  function setupReadingProgress() {
    const progressBar = document.getElementById('reading-progress-bar');
    const progressPercent = document.getElementById('reading-progress-percent');
    const progressWidget = document.querySelector('.reading-progress-widget');
    let progressFadeTimer;

    // å°† scheduleFade çš„å»¶è¿Ÿç”± 350ms è°ƒé•¿ä¸º 1200ms
    const scheduleFade = (delay = 1200) => {
      if (!progressWidget) return;
      if (progressFadeTimer) clearTimeout(progressFadeTimer);
      progressFadeTimer = window.setTimeout(() => {
        progressWidget.classList.add('faded', 'idle');
      }, delay);
    };

    const showWidgetNow = () => {
      if (!progressWidget) return;
      progressWidget.classList.add('visible');
      progressWidget.classList.remove('faded', 'idle');
    };

    const updateReadingProgress = () => {
      if (!progressBar) return;
      const doc = document.documentElement;
      const scrollTop = doc.scrollTop || document.body.scrollTop;
      const height = doc.scrollHeight - doc.clientHeight;
      const percent = height > 0 ? Math.min(100, Math.max(0, (scrollTop / height) * 100)) : 0;
      const pctText = `${percent.toFixed(0)}%`;
      progressBar.style.width = percent + "%";
      progressBar.style.opacity = percent <= 0 ? "0" : "1";
      if (progressPercent) progressPercent.textContent = pctText;
      showWidgetNow();
      scheduleFade(1200); // è¿™é‡Œä¹ŸåŒæ­¥è°ƒé•¿
    };

    // åªç›‘å¬æ»šåŠ¨ï¼Œä¸å†ç›‘å¬é¼ æ ‡/è§¦æ‘¸ç§»åŠ¨
    const bindReadingProgress = () => {
      updateReadingProgress();
      window.removeEventListener('scroll', updateReadingProgress);
      window.addEventListener('scroll', updateReadingProgress, { passive: true });

      window.removeEventListener('mousemove', updateReadingProgress);
      window.removeEventListener('touchmove', updateReadingProgress);

      showWidgetNow();
      scheduleFade(1200);
    };

    bindReadingProgress();
    document.addEventListener('swup:contentReplaced', () => {
      handleReadingProgressDisplay();
      bindReadingProgress();
    });
    document.addEventListener('swup:enable', () => {
      handleReadingProgressDisplay();
      bindReadingProgress();
    }, { once: true });
  }

  // åˆå§‹æŒ‚è½½
  handleReadingProgressDisplay();
  setupReadingProgress();
  document.addEventListener('swup:contentReplaced', handleReadingProgressDisplay);
  document.addEventListener('swup:enable', handleReadingProgressDisplay, { once: true });
</script>

</body>
</html>

